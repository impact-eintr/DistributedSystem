# 概述

这节课是6.824 分布式系统

## 什么是分布式系统
我们知道，它的核心是通过网络使得一群计算机相互通信来完成一些连贯的任务， 在这节课上，我们将关注一些例子，比如大型网站的存储或大数据计算(MapReduce), 以及诸如点对点文件共享之类的更神奇的事情
所有这一切都很重要的原因是：许多关键基础架构是由分布式基础架构构建而成的，这种基础架构需要一台以上的计算机才能完成工作。

人们被迫使用大量计算机进行写作的原因是他们需要以此来获得高性能，以及容错性。此外当我们关心系统的安全性时，我们可以将事情分解为多台计算机来完成。

分布式意味着大量的并行与并发，这给系统构建者带来相当的挑战。
分布式系统不同于单点系统，可能会出现部分故障（有些停止工作，其他继续工作）, 或者计算机正常工作，但网络不可达。**因此，局部故障是分布式系统难以实现的另一个原因。**
此外，想要分布式系统获得高性能也不是一件简单的事。

这是一梦有关应用基础架构的课程，在整个课程中，我们讨论应用程序之间的联系的方式会与其他人所写的方式有所不同，这样的基础架构往往会出现在我们的存储、通信和计算中，我们会讨论提到的所有这三种基础架构的系统。
事实证明，存储这块是我们最为关注的一块内容, 因为他是一个定义明确且有用的抽象，通常是相当简单直接的抽象。所以人们知道很多关于如何使用和构建存储系统，以及如何构建某种具有复制容错的高性能分布式存储实现

# 架构抽象
## RPC
在第一个主题中，我们会看到许多必须去实现的系统，比如你通过很多途径看到过很多种构建这些系统的诸如RPC之类的工具，其目的就是将我们底层通过不可靠网络进行通信这个事实进行隐藏
## Threads
另一个主题是我们将会看到大量的线程,我们通过并发编程来驾驭多核计算机，线程可用于结构化并发操作，通过这个主题希望可以简化程序员对这些并发操作的看法
## 性能
通常，构建分布式系统的高级目标是获得人们所说的通过扩展进行加速
### 扩展性
可扩展性是指，如果我在一台机器解决了一些问题，然后购买了另一台机器来帮助我执行问题，如果我的效率提高了一倍，我们使用两倍的计算机或者资源就能使我们获取两倍的性能或者吞吐量

当我们在构建大型网站的时候，我们并不能通过无限制地增加机器数量来获得性能上的全面提升(数据库往往是性能瓶颈)
### 容错
使用大型分布式系统去解决大型问题会导致极低的容错率，或者原本非常函件的故障问题变得极为常见，大规模会让小概率事件变成一个常见问题，这意味着必须很少发生故障，或者只需要在设计中内置无故障进行能力，也就是掩饰故障的能力，因为故障总会发生。为了能公构建基础架构，我们要尽可能将故障隐藏在应用出现中或者将之掩盖起来(分布式系统要能处理类似的故障，返回对应的处理结果)，这样程序员就不需要为各种各样的故障提供一套完整而复杂的应对方案

#### 可用性
某些系统是针对某些特定的故障设计的，并非是所有的故障，而是某些特定的故障，当遇到这些故障的时候，系统会继续运行，并且提供完好的服务，在某种意义上，配备了这些服务的系统就是可用的，如果你构建了一个可复制的服务，他可能有两个一样的数据。
我们通常所说的可用系统指的是当遇到某些故障后，我们依然能提供可用的服务


#### 可恢复性
这意味着，如果某些东西出错，可能引发服务停止工作，简单来说，系统对请求停止了响应，直到服务修复，系统能够继续运行。
事实上，系统再次运行且又不失正确性仍然是一个重要的需求，通常，可恢复系统需要做到某些事情，例如，将他们最新的数据保存到硬盘上。

在构建高可用的分布式系统时，我们有两样最重要的工具：
- 非易失性存储 
  - 比如将系统状态的检查点或者日志落盘
  - 构建高性能的容错系统需要大量的技巧，避免过多地写入非易失性存储
- 复制
  - 复制副本的管理有些棘手，我们知道任何复制系统中都存在这种保持一致性问题

## 一致性
对于一个常见的K-V数据库而言，一般具有put和get操作，直观来讲，put的意思就是更新表，get就是将表中保存那个版本取出，但在分布式系统中，由于复制或者缓存之类的东西，就会造成有多个数据副本的存在，该键值对可能会有很多不同版本。
如果在客户端put某个数据时，某个节点put失败，那么就会造成分布式系统的数据不一致

如果我们正在构建一个容错系统，有条规则，就是你始终要先访问最上层的服务器(master)，只有master服务下线的时候才会访问备份节点，但总有一个时刻会访问到这些不一致的数据。

人们对弱一致性方案感兴趣的原因是，强一致性确实有理由保证能够看到最新的一致性，这是一个非常昂贵的规范，因为这意味着几乎可以肯定的是，我们必须与他人进行大量交流才能真正实现一些强一致性的概念，如果你有多份副本，意味着要么写入数据，要么又读又写。
在上面的例子中，像这样的每个副本，可能是客户端漰溃导致一个更新，而另一个没有更新，如果我们想实现一个强壮的系统，我们可以在其中找到一个简单的方法，在这个系统中我们会让用户读取这两个副本，如果副本不止一个，则读取所有的副本，并且使用最新写入的值。但这样的读操作耗时太大。

